# 🛒 고객 구매 데이터 대시보드 (Customer Purchase Dashboard)

> **"데이터를 시각화하고 고객 정보를 효율적으로 관리하는 Admin 대시보드"**

---

## 🚀 실행 방법 (Getting Started)

프로젝트 실행을 위해 아래의 단계를 순서대로 진행해 주세요.

### 1. 서버 실행 (Backend)

데이터 API를 제공하는 목업(Mock) 서버를 먼저 실행합니다.

```bash
cd apps
yarn install
yarn start-server
# Server running at http://localhost:4000
```

### 2. 클라이언트 실행 (Frontend)

새로운 터미널 탭에서 클라이언트 애플리케이션을 실행합니다.

```bash
cd apps
yarn start-client
# Application running at http://localhost:3000
```

### 3. 테스트 실행 (Test)

단위 테스트 및 컴포넌트 테스트를 수행합니다.

```bash
cd apps
yarn test
```

---

## 🛠 기술 스택 (Tech Stack)

프로젝트의 유지보수성과 성능, 개발 생산성을 고려하여 다음과 같은 기술을 선택했습니다.

| 기술 (Category)   | 이름 (Name)        | 선택 이유 (Reason)                                                                                                             |
| :---------------- | :----------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| **Framework**     | **React**          | 선언적인 UI 구성과 풍부한 생태계를 활용하여 복잡한 상태를 효율적으로 관리하기 위해 선택했습니다.                               |
| **Language**      | **TypeScript**     | 정적 타입을 통해 컴파일 단계에서 오류를 방지하고, IDE의 자동 완성 지원으로 생산성을 높였습니다.                                |
| **Styling**       | **TailwindCSS**    | 유틸리티 클래스 기반으로 빠른 스타일링이 가능하며, `tailwind-merge`를 통해 컴포넌트 스타일을 유연하게 확장할 수 있습니다.      |
| **State Mgt**     | **TanStack Query** | 서버 상태(Server State) 관리와 로딩/에러 처리를 내장 기능을 통해 선언적으로 처리하고, 캐싱으로 불필요한 요청을 최소화했습니다. |
| **Visualization** | **Recharts**       | React 친화적인 컴포넌트 구조로 차트 커스터마이징이 용이하며, 과제의 시각화 요구사항을 빠르게 구현할 수 있습니다.               |
| **Routing**       | **React Router**   | `createBrowserRouter`를 사용해 라우트별 에러 경계(Error Boundary)와 레이아웃을 구조적으로 분리했습니다.                        |

---

## 🌟 주요 기능 (Key Features)

### 📊 1. 데이터 시각화 (Dashboard)

- **가격대별 구매 빈도 차트**: 2만원 이하부터 10만원 이상까지, 1만원 단위 구간별 구매 빈도를 Bar Chart로 시각화했습니다.
- **기간 필터링**: `DateRangePicker`를 통해 원하는 날짜 범위를 설정하고 데이터를 즉시 조회할 수 있습니다.

### 👥 2. 고객 관리 (Customer Management)

- **고객 목록 조회**: 페이지네이션이 적용된 테이블 UI를 제공합니다.
- **고급 정렬**: ID(기본), 총 구매 금액(오름차순/내림차순) 정렬을 지원하여 데이터를 다각도로 분석할 수 있습니다.
- **실시간 검색**: 고객 이름을 검색할 때 `Debounce` 처리를 적용하여 서버 부하를 줄이면서도 빠른 검색 경험을 제공합니다.

### 📝 3. 상세 정보 조회 (Detail View)

- **구매 내역 모달**: 고객 행을 클릭하면 모달 내에서 해당 고객의 상세 정보와 구매 내역(상품명, 썸네일, 가격 등)을 확인할 수 있습니다.
- **통합 뷰**: 구매 내역뿐만 아니라 고객의 핵심 정보도 모달 내에 함께 표시하여 컨텍스트 스위칭을 최소화했습니다.

### 🛡 4. UX & 안전장치

- **스켈레톤(Skeleton) 로딩**: 데이터 로딩 중 레이아웃 이동(CLS)을 방지하고 체감 속도를 높였습니다.
- **에러 바운더리(Error Boundary)**: 차트나 테이블 등 특정 영역에서 에러가 발생하더라도 전체 앱이 멈추지 않고, 해당 영역에서만 복구 UI를 제공합니다.

---

## 📂 디렉토리 구조 (Directory Structure)

**도메인 주도 설계(DDD)** 의 개념을 차용하여, 기능(Feature) 단위로 응집도를 높이는 구조를 채택했습니다.

```bash
apps/frontend/src/
├── main.tsx                # 앱 엔트리 포인트 (Provider 주입)
├── routes/                 # 라우팅 설정 (앱의 뼈대)
├── pages/                  # [Page & Feature Layer] 도메인별 기능 및 라우트
│   ├── customer/           # 고객 도메인 (테이블, 검색, 상세조회 컴포넌트 포함)
│   └── dashboard/          # 대시보드 도메인 (차트, 필터 컴포넌트 포함)
├── apis/                   # [API Layer] 서버 통신 로직
│   ├── client.ts           # Axios 인스턴스
│   └── endpoints/          # API 엔드포인트 정의
├── shared/                 # [Shared Layer] 도메인에 종속되지 않는 공용 요소
│   ├── components/         # UI 컴포넌트 (Modal, Skeleton, Button 등)
│   ├── hooks/              # 유틸리티 훅 (useModal, useDebounce)
│   └── layouts/            # 레이아웃 (Layout, Sidebar)
└── lib/                    # 외부 라이브러리 설정 (QueryClient 등)
```

> **설계 원칙**:
>
> - **Co-location (동일 위치 원칙)**: 각 페이지(도메인)에서만 사용되는 컴포넌트와 훅은 해당 페이지 폴더(`pages/[domain]`) 내부에 배치하여 응집도를 높였습니다.
> - `shared`는 어플리케이션 전반에서 재사용되는 UI 컴포넌트와 유틸리티만 포함하여 의존성 방향을 명확히 했습니다.

---

## 💡 설계 및 개발 고민 (Deep Dive)

프로젝트를 진행하며 고민했던 기술적 의사결정과 문제 해결 과정을 공유합니다.

### 1. 관심사의 분리와 아키텍처 (Architecture)

과제가 확장될 가능성을 고려하여 **'기능의 응집'**과 **'결합도'**에 집중했습니다.
초기에는 `components/` 폴더에 모든 것을 넣기 쉽지만, 이는 프로젝트가 커질수록 유지보수를 어렵게 합니다.
따라서, **구매 현황(Dashboard)** 과 **고객 관리(Customer)** 라는 명확한 도메인 경계를 기준으로 폴더를 분리했습니다. 이를 통해 특정 기능을 수정할 때 영향 범위를 쉽게 파악할 수 있도록 설계했습니다.

### 2. 효율적인 상태 관리 전략 (State Management)

- **Server State**: 데이터의 신선도(Freshness)가 중요한 비즈니스 데이터는 `TanStack Query`를 사용했습니다. `staleTime`을 적절히 설정하여 불필요한 네트워크 요청을 방지했습니다.
- **UI State**: 모달의 열림/닫힘, 입력 필드 값과 같은 휘발성 상태는 `useState`나 `Context API`(Pagination 등)를 사용하여 컴포넌트 내부에 캡슐화했습니다.

### 3. 견고한 에러 처리 (Robust Error Handling)

에러는 언제든 발생할 수 있습니다. 중요한 것은 **'사용자 경험을 해치지 않는 복구'**입니다.

- **부분적 실패 격리**: 차트 데이터를 불러오는 데 실패했다고 해서, 사이드바나 헤더까지 사라지면 안 됩니다. `ErrorBoundary`를 주요 섹션별로 적용하여, 에러가 전파되는 것을 막고 "다시 시도" 버튼을 제공해 사용자가 스스로 복구할 수 있도록 유도했습니다.
- **404 처리**: 검색 결과가 없거나 잘못된 페이지 접근 시, 단순히 에러를 던지는 대신 "데이터가 없습니다"와 같은 친절한 UI로 대체하여 자연스러운 흐름을 유지했습니다.

### 4. 사용자 경험(UX)을 위한 디테일 (UX Details)

- **검색 Debounce**: 검색어를 입력할 때마다 API를 호출하면 서버 과부하와 UI 깜빡임이 발생합니다. `useDebounce` 훅을 구현하여 입력이 멈춘 후 300ms 뒤에 요청을 보내도록 최적화했습니다.
- **모달 컨텍스트 유지**: 고객 상세 정보 모달에서 단순히 데이터만 보여주는 것이 아니라, 고객의 이름과 핵심 정보를 헤더에 고정하여 "누구의 데이터를 보고 있는지" 끊임없이 인지할 수 있도록 개선했습니다.
- **잘못된 필터 방지**: 기간 선택 시 종료일이 시작일보다 앞서는 모순된 상황을 방지하고, 사용자에게 `alert` 메시지로 피드백을 주어 올바른 입력을 유도했습니다.

### 5. 확장 가능한 사이드바 구조

단순히 `Dashboard` 페이지만 있는 것이 아니라, 향후 `Orders`나 `Settings` 같은 메뉴가 추가될 것을 대비했습니다.
사이드바를 독립적인 레이아웃 컴포넌트로 분리하고, 메인 콘텐츠 영역(`Outlet`)만 교체되는 `AppLayout` 구조를 채택하여 확장성을 확보했습니다.

---

**작성자**: 프론트엔드 개발자 (이재민)
